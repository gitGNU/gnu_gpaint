#! /bin/sh /usr/share/dpatch/dpatch-run
## 10_real_clipboard.dpatch by Steven McCoy <steven.mccoy@miru.hk>
##
## DP: Implements copy and paste to/from the real system clipboard

@DPATCH@
diff -urNad gpaint-0.3.1~/src/canvas.c gpaint-0.3.1/src/canvas.c
--- gpaint-0.3.1~/src/canvas.c	2007-06-11 05:35:02.000000000 -0300
+++ gpaint-0.3.1/src/canvas.c	2007-08-17 16:53:48.000000000 -0300
@@ -36,6 +36,9 @@
 #include "paste.h"
 #include "selection.h"
 
+
+#define GPAINT_CLIPBOARD_KEY "gpaint-clipboard"
+
 /* Single clipboard to share selections between canvases. */
 static gpaint_clipboard *clipboard = NULL;
 
@@ -44,12 +47,25 @@
 #define ACTIVE_TOOL(user_data) (((gpaint_canvas*)(user_data))->active_tool)
 #define DRAWING(user_data)     (((gpaint_canvas*)(user_data))->drawing)
 
+/* gobject canvas */
+#define GPAINT_TYPE_CANVAS		(gpaint_canvas_get_type ())
+#define GPAINT_CANVAS(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), GPAINT_TYPE_CANVAS, gpaint_canvas))
+#define GPAINT_CANVAS_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), GPAINT_TYPE_CANVAS, gpaint_canvas_class))
+#define GPAINT_IS_CANVAS(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GPAINT_TYPE_CANVAS))
+#define GPAINT_IS_CANVAS_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), GPAINT_TYPE_CANVAS))
+#define GPAINT_CANVAS_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), GPAINT_TYPE_CANVAS, gpaint_canvas_class))
+
+GType gpaint_canvas_get_type (void);
+
 /* File to open when starting. */
 static const gchar* canvas_initial_filename = 0;
 
 static gpaint_canvas* canvas_new(GtkDrawingArea *drawing_area);
 static void canvas_copy_selection_to_clipboard(gpaint_canvas *canvas);
 
+static void canvas_clipboard_free (gpaint_clipboard *clipboard);
+static gint canvas_clipboard_format_compare (GdkPixbufFormat *a, GdkPixbufFormat *b);
+static void canvas_clipboard_send_buffer(GtkClipboard *gtk_clipboard, GtkSelectionData *selection_data, guint info, gpaint_canvas *canvas);
 
 static void 
 on_drawing_area_realize           (GtkWidget       *widget,
@@ -395,7 +411,8 @@
     gdk_gc_set_line_attributes(gc, 1, GDK_LINE_SOLID, GDK_CAP_ROUND, GDK_JOIN_ROUND);
    
     /* Create the canvas object */
-    canvas = (gpaint_canvas*)g_new0(gpaint_canvas, 1);
+//    canvas = (gpaint_canvas*)g_new0(gpaint_canvas, 1);
+    canvas = g_object_new (GPAINT_TYPE_CANVAS, NULL);
     g_assert(canvas);
     canvas->top_level = gtk_widget_get_toplevel(GTK_WIDGET(drawing_area));
     canvas->drawing_area = drawing_area;    
@@ -429,6 +446,33 @@
     return canvas;
 }  
 
+GType
+gpaint_canvas_get_type (void)
+{
+    static GType object_type = 0;
+
+    if (!object_type)
+    {
+	static const GTypeInfo object_info =
+	{
+	    sizeof (gpaint_canvas_class),
+	    (GBaseInitFunc) NULL,
+	    (GBaseFinalizeFunc) NULL,
+	    (GClassInitFunc) NULL,
+	    NULL,	/* class_finalize */
+	    NULL,	/* class_data */
+	    sizeof (gpaint_canvas),
+	    0,
+	    (GInstanceInitFunc) canvas_init,
+	};
+
+	object_type = g_type_register_static (G_TYPE_OBJECT,
+						"GpaintCanvas",
+						&object_info, 0);
+    }
+
+    return object_type;
+}
 
 void
 canvas_destroy(gpaint_canvas *canvas)
@@ -448,8 +492,9 @@
     gdk_gc_unref(canvas->gc);
     gdk_cursor_destroy(canvas->arrow_cursor);
     gdk_cursor_destroy(canvas->busy_cursor);
-    memset(canvas, 0xBEBE, sizeof(canvas)); /* debugging aid */
-    g_free(canvas);
+//    memset(canvas, 0xBEBE, sizeof(canvas)); /* debugging aid */
+//    g_free(canvas);
+    g_object_unref(canvas);
     debug("canvas_destroy() returning");
 }
 
@@ -595,7 +640,7 @@
 canvas_begin_paste_mode(gpaint_canvas *canvas)
 {
     gpaint_clipboard *clipboard = canvas_clipboard(canvas);
-    if (clipboard && point_array_size(clipboard->points)) 
+//    if (clipboard && point_array_size(clipboard->points)) 
     {
         if (canvas->active_tool != canvas->paste_tool)
         {
@@ -676,17 +721,97 @@
     /* create the single clipboard */
     if (!clipboard)
     {
+	GSList *list;
+
         clipboard = g_new0(gpaint_clipboard, 1);
         clipboard->image = 0;
         clipboard->points = point_array_new();
+
+/* create gobject for clipboard notifications */
+	g_object_set_data_full (G_OBJECT (canvas), GPAINT_CLIPBOARD_KEY,
+				clipboard, (GDestroyNotify) canvas_clipboard_free);
+
+/* create list of pixbuf formats for clipboard format negotiation */
+
+        clipboard->pixbuf_formats =
+		g_slist_sort (gdk_pixbuf_get_formats(),
+				(GCompareFunc) canvas_clipboard_format_compare);
+	for (list = clipboard->pixbuf_formats; list; list = g_slist_next (list))
+	{
+	    GdkPixbufFormat *format = list->data;
+
+	    if (gdk_pixbuf_format_is_writable (format))
+	    {
+		gchar **mime_types;
+		gchar **type;
+
+		mime_types = gdk_pixbuf_format_get_mime_types (format);
+
+		for (type = mime_types; *type; type++)
+		    clipboard->n_target_entries++;
+
+		g_strfreev (mime_types);
+	    }
+	}
+
+	if (clipboard->n_target_entries > 0)
+	{
+	    gint i = 0;
+
+	    clipboard->target_entries = g_new0(GtkTargetEntry,
+						clipboard->n_target_entries);
+	    clipboard->savers 	      = g_new0(gchar*,
+						clipboard->n_target_entries + 1);
+
+	    for (list = clipboard->pixbuf_formats; list; list = g_slist_next (list))
+	    {
+	        GdkPixbufFormat *format = list->data;
+
+	        if (gdk_pixbuf_format_is_writable (format))
+	        {
+		    gchar *format_name;
+		    gchar **mime_types;
+		    gchar **type;
+
+		    format_name = gdk_pixbuf_format_get_name (format);
+		    mime_types = gdk_pixbuf_format_get_mime_types (format);
+
+		    for (type = mime_types; *type; type++)
+		    {
+			gchar *mime_type = *type;
+
+			clipboard->target_entries[i].target = g_strdup (mime_type);
+			clipboard->target_entries[i].flags  = 0;
+			clipboard->target_entries[i].info   = i;
+
+			clipboard->savers[i]                = g_strdup (format_name);
+
+			i++;
+		    }
+
+		    g_strfreev (mime_types);
+		    g_free (format_name);
+		}
+	    }
+	}
     }
     return clipboard;
 }
 
 static void
+canvas_clipboard_free (gpaint_clipboard *clipboard)
+{
+    g_slist_free (clipboard->pixbuf_formats);
+    g_free (clipboard->target_entries);
+    g_strfreev (clipboard->savers);
+    g_free (clipboard);
+}
+
+static void
 canvas_copy_selection_to_clipboard(gpaint_canvas *canvas)
 {
     gpaint_clipboard *clipboard = canvas_clipboard(canvas);
+    GtkClipboard *gtk_clipboard;
     
     if (clipboard->image)
     {
@@ -696,5 +821,107 @@
                             canvas->drawing->backing_pixmap,
                             selection_points(canvas->selection));
     point_array_copy(clipboard->points, selection_points(canvas->selection));
+
+    gtk_clipboard = gtk_clipboard_get_for_display (gdk_display_get_default(),
+						   GDK_SELECTION_CLIPBOARD);
+    if (!gtk_clipboard)
+        return;
+
+    if (clipboard->image)
+    {
+        gtk_clipboard_set_with_owner (gtk_clipboard,
+    					clipboard->target_entries,
+					clipboard->n_target_entries,
+					(GtkClipboardGetFunc) canvas_clipboard_send_buffer,
+					(GtkClipboardClearFunc) NULL,
+					G_OBJECT (canvas));
+    }
+    else if (gtk_clipboard_get_owner (gtk_clipboard) == G_OBJECT(canvas))
+    {
+        gtk_clipboard_clear (gtk_clipboard);
+    }
+}   
+
+static GdkPixbuf* 
+clipboard_pixbuf(gpaint_clipboard *clipboard) {
+    return image_pixbuf(clipboard->image);
+}
+
+
+static void
+canvas_clipboard_send_buffer(GtkClipboard	*gtk_clipboard,
+			     GtkSelectionData	*selection_data,
+			     guint		 info,
+			     gpaint_canvas	*canvas)
+{
+    gpaint_clipboard *clipboard = canvas_clipboard(canvas);
+    GdkPixbuf *pixbuf = clipboard_pixbuf(clipboard);
+
+    if (pixbuf)
+    {
+        GdkAtom atom = gdk_atom_intern (clipboard->target_entries[info].target,
+					FALSE);
+
+	g_print ("sending pixbuf data as '%s' (%s)\n",
+			clipboard->target_entries[info].target,
+			clipboard->savers[info]);
+	gchar *buffer;
+	gsize buffer_size;
+	GError *error = NULL;
+
+	g_return_if_fail (selection_data != NULL);
+	g_return_if_fail (atom != GDK_NONE);
+	g_return_if_fail (GDK_IS_PIXBUF (pixbuf));
+	g_return_if_fail (clipboard->savers[info] != NULL);
+
+	if (gdk_pixbuf_save_to_buffer (pixbuf,
+					&buffer, &buffer_size, clipboard->savers[info],
+					&error, NULL))
+	{
+	    gtk_selection_data_set (selection_data, atom,
+					8, (guchar*) buffer, buffer_size);
+        }
+    }
+}
+
+static gint
+canvas_clipboard_format_compare (GdkPixbufFormat *a,
+				 GdkPixbufFormat *b)
+{
+    gchar *a_name = gdk_pixbuf_format_get_name (a);
+    gchar *b_name = gdk_pixbuf_format_get_name (b);
+    gint retval = 0;
+
+#ifdef GDK_WINDOWING_WIN32
+    /*  move BMP to the front of the list  */
+    if (g_ascii_strncasecmp (a_name, "bmp", strlen("bmp")) == 0)
+        retval = -1;
+    else if (g_ascii_strncasecmp (b_name, "bmp", strlen("bmp")) == 0)
+        retval = 1;
+    else
+#endif
+
+    /*  move PNG to the front of the list  */
+    if (g_ascii_strncasecmp (a_name, "png", strlen("png")) == 0)
+        retval = -1;
+    else if (g_ascii_strncasecmp (b_name, "png", strlen("png")) == 0)
+        retval = 1;
+
+    /*  move JPEG to the end of the list  */
+    else if (g_ascii_strncasecmp (a_name, "jpeg", strlen("jpeg")) == 0)
+        retval = 1;
+    else if (g_ascii_strncasecmp (b_name, "jpeg", strlen("jpeg")) == 0)
+        retval = -1;
+
+    /*  move GIF to the end of the list  */
+    else if (g_ascii_strncasecmp (a_name, "gif", strlen("gif")) == 0)
+        retval = 1;
+    else if (g_ascii_strncasecmp (b_name, "gif", strlen("gif")) == 0)
+        retval = -1;
+
+    g_free (a_name);
+    g_free (b_name);
+
+    return retval;
 }   
 
diff -urNad gpaint-0.3.1~/src/canvas.h gpaint-0.3.1/src/canvas.h
--- gpaint-0.3.1~/src/canvas.h	2007-06-11 05:34:49.000000000 -0300
+++ gpaint-0.3.1/src/canvas.h	2007-08-17 16:53:48.000000000 -0300
@@ -34,6 +34,7 @@
 #define DEFAULT_HEIGHT 480
 
 typedef struct _gpaint_canvas    gpaint_canvas;
+typedef struct _gpaint_canvas_class    gpaint_canvas_class;
 typedef struct _gpaint_tool      gpaint_tool;
 
 typedef enum _gpaint_attribute 
@@ -88,10 +89,23 @@
 {
     gpaint_image       *image;
     gpaint_point_array *points;
+
+    GSList	       *pixbuf_formats;
+
+    GtkTargetEntry     *target_entries;
+    gint		n_target_entries;
+    gchar	      **savers;
 } gpaint_clipboard;
 
+struct _gpaint_canvas_class
+{
+    GObjectClass      parent;
+};
+
 struct _gpaint_canvas 
 {
+    GObject	      parent;
+
     /* public */
     GtkWidget        *top_level;       
     GtkDrawingArea   *drawing_area;
diff -urNad gpaint-0.3.1~/src/drawing.c gpaint-0.3.1/src/drawing.c
--- gpaint-0.3.1~/src/drawing.c	2007-06-11 05:35:01.000000000 -0300
+++ gpaint-0.3.1/src/drawing.c	2007-08-17 16:53:48.000000000 -0300
@@ -428,7 +428,11 @@
                drawing->filename->str);
         gtk_dialog_add_button(GTK_DIALOG(dialog), GTK_STOCK_SAVE,GTK_RESPONSE_YES);
         gtk_dialog_add_button(GTK_DIALOG(dialog), GTK_STOCK_CANCEL,GTK_RESPONSE_CANCEL);
+#ifdef GTK_STOCK_DISCARD
+        gtk_dialog_add_button(GTK_DIALOG(dialog), GTK_STOCK_DISCARD,GTK_RESPONSE_DISCARD);
+#else
         gtk_dialog_add_button(GTK_DIALOG(dialog), GTK_STOCK_NO,GTK_RESPONSE_NO);
+#endif /* !GTK_STOCK_DISCARD */
         
         result = gtk_dialog_run(GTK_DIALOG(dialog));
         gtk_widget_destroy(GTK_WIDGET(dialog));
diff -urNad gpaint-0.3.1~/src/image.c gpaint-0.3.1/src/image.c
--- gpaint-0.3.1~/src/image.c	2007-08-17 16:53:48.000000000 -0300
+++ gpaint-0.3.1/src/image.c	2007-08-17 16:53:48.000000000 -0300
@@ -631,3 +631,6 @@
 }
 
 
+GdkPixbuf* image_pixbuf(gpaint_image* image) {
+    return image->pixbuf;
+};
diff -urNad gpaint-0.3.1~/src/image.h gpaint-0.3.1/src/image.h
--- gpaint-0.3.1~/src/image.h	2007-06-11 05:34:43.000000000 -0300
+++ gpaint-0.3.1/src/image.h	2007-08-17 16:54:13.000000000 -0300
@@ -47,4 +47,5 @@
 int            image_flip_x(gpaint_image *image);
 int            image_flip_y(gpaint_image *image);
 int            image_rotate(gpaint_image *image, double radians);
+GdkPixbuf*     image_pixbuf(gpaint_image *image);
 #endif
diff -urNad gpaint-0.3.1~/src/paste.c gpaint-0.3.1/src/paste.c
--- gpaint-0.3.1~/src/paste.c	2007-08-17 16:53:48.000000000 -0300
+++ gpaint-0.3.1/src/paste.c	2007-08-17 16:53:48.000000000 -0300
@@ -88,6 +88,140 @@
     g_free(tool);
 }
 
+static GdkAtom*
+paste_clipboard_wait_for_targets (gint *n_targets)
+{
+    GtkClipboard *gtk_clipboard;
+  
+    gtk_clipboard = gtk_clipboard_get_for_display (gdk_display_get_default (),
+	                                             GDK_SELECTION_CLIPBOARD);
+
+    if (gtk_clipboard)
+    {
+        GtkSelectionData *data;
+
+        data = gtk_clipboard_wait_for_contents (gtk_clipboard,
+                                              gdk_atom_intern ("TARGETS",
+                                                               FALSE));
+        if (data)
+        {
+            GdkAtom  *targets;
+            gboolean  success;
+
+            success = gtk_selection_data_get_targets (data, &targets, n_targets);
+
+            gtk_selection_data_free (data);
+
+            if (success)
+            {
+                gint i;
+
+                for (i = 0; i < *n_targets; i++)
+                    g_print ("offered type: %s\n", gdk_atom_name (targets[i]));
+
+                g_print ("\n");
+
+                return targets;
+            }
+        }
+    }
+
+    return NULL;
+}
+
+static GdkAtom
+paste_clipboard_wait_for_buffer (gpaint_canvas *canvas)
+{
+    gpaint_clipboard *clipboard = canvas_clipboard(canvas);
+    GdkAtom *targets;
+    gint n_targets;
+    GdkAtom result = GDK_NONE;
+
+    targets = paste_clipboard_wait_for_targets (&n_targets);
+
+    if (targets)
+    {
+	GSList *list;
+
+        for (list = clipboard->pixbuf_formats; list; list = g_slist_next (list))
+        {
+          GdkPixbufFormat  *format = list->data;
+          gchar           **mime_types;
+          gchar           **type;
+
+          g_print ("checking pixbuf format '%s'\n",
+                   gdk_pixbuf_format_get_name (format));
+
+          mime_types = gdk_pixbuf_format_get_mime_types (format);
+
+          for (type = mime_types; *type; type++)
+          {
+              gchar   *mime_type = *type;
+              GdkAtom  atom      = gdk_atom_intern (mime_type, FALSE);
+              gint     i;
+
+              g_print (" - checking mime type '%s'\n", mime_type);
+
+              for (i = 0; i < n_targets; i++)
+              {
+                  if (targets[i] == atom)
+                  {
+                      result = atom;
+                      break;
+                  }
+              }
+
+              if (result != GDK_NONE)
+                break;
+          }
+
+          g_strfreev (mime_types);
+
+          if (result != GDK_NONE)
+              break;
+        }
+
+        g_free (targets);
+    }
+
+    return result;
+}
+
+GdkPixbuf*
+paste_selection_data_get_pixbuf (GtkSelectionData *selection)
+{
+    GdkPixbufLoader *loader;
+    GdkPixbuf       *pixbuf = NULL;
+    GError          *error  = NULL;
+  
+    g_return_val_if_fail (selection != NULL, NULL);
+  
+    if ((selection->format != 8) || (selection->length < 1))
+    {
+        g_warning ("Received invalid image data!");
+        return NULL;
+    }
+  
+    loader = gdk_pixbuf_loader_new ();
+  
+    if (gdk_pixbuf_loader_write (loader,
+                                 selection->data, selection->length, &error) &&
+                                 gdk_pixbuf_loader_close (loader, &error))
+    {
+        pixbuf = gdk_pixbuf_loader_get_pixbuf (loader);
+        g_object_ref (pixbuf);
+    }
+    else
+    {
+        g_warning ("%s: %s", G_STRFUNC, error->message);
+        g_error_free (error);
+    }
+  
+    g_object_unref (loader);
+  
+    return pixbuf;
+}
+
 static void
 paste_select(gpaint_tool *tool)
 {
@@ -95,10 +229,63 @@
     gpaint_canvas *canvas   = tool->canvas;
     gpaint_drawing *drawing = tool->drawing;
     gpaint_clipboard *clipboard = canvas_clipboard(tool->canvas);
+    GtkClipboard *gtk_clipboard;
  
     /* make a backup of the current drawing */
     paste->backup_image = drawing_create_image(drawing);
     
+ /* check for image data on real clipboard */
+     gtk_clipboard = gtk_clipboard_get_for_display (gdk_display_get_default(),
+ 							GDK_SELECTION_CLIPBOARD);
+     if (gtk_clipboard && gtk_clipboard_get_owner (gtk_clipboard) != G_OBJECT (canvas))
+     {
+ 	GdkAtom atom = paste_clipboard_wait_for_buffer (canvas);
+ 
+ 	if (atom != GDK_NONE)
+ 	{
+ 	    GtkSelectionData *data;
+ 
+ 	    data = gtk_clipboard_wait_for_contents (gtk_clipboard, atom);
+ 
+ 	    if (data)
+ 	    {
+ 		GdkPixbuf *pixbuf = paste_selection_data_get_pixbuf (data);
+ 
+ 		gtk_selection_data_free (data);
+ 
+ 		if (pixbuf)
+ 		{
+ 		    gpaint_point_array *clipboard_points;
+ 		    int width, height;
+ 		    GdkPixbuf** pixbufp = &pixbuf;
+ 
+ 		    if (clipboard->image)
+ 		    {
+ 			image_free(clipboard->image);
+ 		    }
+ 
+ 		    width = gdk_pixbuf_get_width (pixbuf);
+ 		    height = gdk_pixbuf_get_height (pixbuf);
+ 		    clipboard->image = image_new_copy ((gpaint_image*)pixbufp);
+ 
+ /* define clipboard points */
+ 		    point_array_remove_all (clipboard->points);
+ 		    point_array_append (clipboard->points, 0, 0);
+ 		    point_array_append (clipboard->points, width, 0);
+ 		    point_array_append (clipboard->points, width, height);
+ 		    point_array_append (clipboard->points, 0, height);
+ 		    point_array_append (clipboard->points, 0, 0);
+ 
+ 		    g_object_unref (pixbuf);
+ 		}
+ 	    }
+ 	}
+     }
+ 
+ /* check for invalid paste */
+     if (!point_array_size(clipboard->points))
+ 	return;
+     
     /* make a copy of the current clipboad contents and selection points */
     paste->overlay_image   = image_new_copy(clipboard->image);
     selection_set_points(canvas->selection, clipboard->points);
@@ -111,7 +298,10 @@
 {
     gpaint_paste *paste = GPAINT_PASTE(tool);
     selection_remove_points(tool->canvas->selection);
+    if (paste->overlay_image)
+    {
     image_free(paste->overlay_image);
+    }
     image_free(paste->backup_image);
     paste->offset_x = 0;
     paste->offset_y = 0;
